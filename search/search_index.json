{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! \u00b6 Welcome to More Data Structures! Here you'll be able to reinforce the material you'll be learning in your Data Structures course. Please refer to the navigation buttons above to select a topic and view material their corresponding material. Here is what you can expect More Data Structures to provide: A set of problems for each topic Coding exercises that are integrated with Git and GitHub Useful links and resources CSUF Supplemental Instruction \u00b6 This website is intended to be a supplement to Oscar's assigned CPSC 131 Data Structures Supplemental Instruction session. As a result, the content on this website will be completely wiped and re-developed at the beginning of every California State University, Fullerton (CSUF) semester. Topics are released on a rolling basis. Release dates are based off what the 131 professors have covered so far. Additionally, this means that some of the content on here may be difficult to understand if you do not attend the SI sessions. Please utilize the comment sections if you are having trouble and are unable to make the SI sessions.","title":"Home"},{"location":"#welcome","text":"Welcome to More Data Structures! Here you'll be able to reinforce the material you'll be learning in your Data Structures course. Please refer to the navigation buttons above to select a topic and view material their corresponding material. Here is what you can expect More Data Structures to provide: A set of problems for each topic Coding exercises that are integrated with Git and GitHub Useful links and resources","title":"Welcome!"},{"location":"#csuf-supplemental-instruction","text":"This website is intended to be a supplement to Oscar's assigned CPSC 131 Data Structures Supplemental Instruction session. As a result, the content on this website will be completely wiped and re-developed at the beginning of every California State University, Fullerton (CSUF) semester. Topics are released on a rolling basis. Release dates are based off what the 131 professors have covered so far. Additionally, this means that some of the content on here may be difficult to understand if you do not attend the SI sessions. Please utilize the comment sections if you are having trouble and are unable to make the SI sessions.","title":"CSUF Supplemental Instruction"},{"location":"set-up/","text":"Overview \u00b6 Every week, a new set of programming exercises will be introduced via GitHub. You can find the exercises at the repository https://github.com/omolazabal/si-fall-2019 . Continue reading to learn how to use the repository. The structures of the repository is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . \u251c\u2500 1-dynamic-memory/ # Dynamic memory topic \u2502 \u251c\u2500 codebase \u2502 \u2514\u2500 ... \u2502 \u251c\u2500 2-fixed-vector/ # Vectors topic \u2502 \u251c\u2500 codebase \u2502 \u2514\u2500 ... \u2502 \u251c\u2500 ... # Other topics \u2502 \u2514\u2500 ... \u2502 \u251c\u2500 7-recursion/a # Recursion topics \u2502 \u251c\u2500 codebase \u2502 \u2514\u2500 ... Where each directory labeled with a number represents a topic and their sub-directories represents their codebase. Note Topics will be added as the semester progresses as described on the homepage . Each topic's codebase contains functions with missing code segments. Participants will be tasked with filling in the missing information. Details on the missing information can be found under the topic's respective tab on this website. At the end of the week, the topic's respective codebase will be upadated with solutions, in case participants were unable to finish during the SI session. Getting started \u00b6 Download and set up Tuffix . Create a GitHub account Fork the SI GitHub repository . You can accomplish this by clicking the Fork button on the top right corner of the repository's page. Navigating to your preferred workspace in your terminal to work on the repository locally. Use this guide if necessary. Clone your forked repository by running the following command. Replace YOUR_GITHUB_USERNAME with your GitHub username. 1 git clone https://github.com/YOUR_GITHUB_USERNAME/si-fall-2019.git Workflow \u00b6 Initial Set Up \u00b6 Before you begin working on programming exercises, you'll have to configure your repository so that you can update it with new problems. This can be done by running the following command in your terminal while in your repository: 1 ./gitconfig Warning This only has to be done once. If you were to run this command again, all of your progress from all topics will be erased Updating Your Set of Exercises \u00b6 Every week of the semester this repository will be updated with new exercises. The files of each exercise will available in their respective folder. The task is to fill out the empty functions. To update your repository with the latest problems, run the command: 1 ./update Editing Code Segments \u00b6 Code segments you are intended to modify are labeled via comments: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"course.h\" #include \"student.h\" #include <stdexcept> using namespace std ; Course :: Course () { // Initialize member variables. // By default, course will hold a max of 25 students. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Please only modify the code between the lines. If changes are made elsewhere, there will be issues when attempting to update your repository with new problems. Testing Your Changes \u00b6 To execute your programs, run the following command at the root of your repository: 1 ./run folder_name Where the ./run signifies you want to run tests the corresponding code in the folder named folder_name . Please replace folder_name with the name of whichever folder you would like to test. For example, the following command will un the unit tests associated with the 1-dynamic-memory problem set: 1 ./run 1-dynamic-memory If you wish to run all tests, use the command: 1 ./run Summary of commands \u00b6 Command Action ./gitconfig Initial git configuration ./update Update workspace with newly available problems ./run [folder name] Run unit tests to see how your programs perform","title":"Coding Exercises"},{"location":"set-up/#overview","text":"Every week, a new set of programming exercises will be introduced via GitHub. You can find the exercises at the repository https://github.com/omolazabal/si-fall-2019 . Continue reading to learn how to use the repository. The structures of the repository is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . \u251c\u2500 1-dynamic-memory/ # Dynamic memory topic \u2502 \u251c\u2500 codebase \u2502 \u2514\u2500 ... \u2502 \u251c\u2500 2-fixed-vector/ # Vectors topic \u2502 \u251c\u2500 codebase \u2502 \u2514\u2500 ... \u2502 \u251c\u2500 ... # Other topics \u2502 \u2514\u2500 ... \u2502 \u251c\u2500 7-recursion/a # Recursion topics \u2502 \u251c\u2500 codebase \u2502 \u2514\u2500 ... Where each directory labeled with a number represents a topic and their sub-directories represents their codebase. Note Topics will be added as the semester progresses as described on the homepage . Each topic's codebase contains functions with missing code segments. Participants will be tasked with filling in the missing information. Details on the missing information can be found under the topic's respective tab on this website. At the end of the week, the topic's respective codebase will be upadated with solutions, in case participants were unable to finish during the SI session.","title":"Overview"},{"location":"set-up/#getting-started","text":"Download and set up Tuffix . Create a GitHub account Fork the SI GitHub repository . You can accomplish this by clicking the Fork button on the top right corner of the repository's page. Navigating to your preferred workspace in your terminal to work on the repository locally. Use this guide if necessary. Clone your forked repository by running the following command. Replace YOUR_GITHUB_USERNAME with your GitHub username. 1 git clone https://github.com/YOUR_GITHUB_USERNAME/si-fall-2019.git","title":"Getting started"},{"location":"set-up/#workflow","text":"","title":"Workflow"},{"location":"set-up/#initial-set-up","text":"Before you begin working on programming exercises, you'll have to configure your repository so that you can update it with new problems. This can be done by running the following command in your terminal while in your repository: 1 ./gitconfig Warning This only has to be done once. If you were to run this command again, all of your progress from all topics will be erased","title":"Initial Set Up"},{"location":"set-up/#updating-your-set-of-exercises","text":"Every week of the semester this repository will be updated with new exercises. The files of each exercise will available in their respective folder. The task is to fill out the empty functions. To update your repository with the latest problems, run the command: 1 ./update","title":"Updating Your Set of Exercises"},{"location":"set-up/#editing-code-segments","text":"Code segments you are intended to modify are labeled via comments: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \"course.h\" #include \"student.h\" #include <stdexcept> using namespace std ; Course :: Course () { // Initialize member variables. // By default, course will hold a max of 25 students. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Please only modify the code between the lines. If changes are made elsewhere, there will be issues when attempting to update your repository with new problems.","title":"Editing Code Segments"},{"location":"set-up/#testing-your-changes","text":"To execute your programs, run the following command at the root of your repository: 1 ./run folder_name Where the ./run signifies you want to run tests the corresponding code in the folder named folder_name . Please replace folder_name with the name of whichever folder you would like to test. For example, the following command will un the unit tests associated with the 1-dynamic-memory problem set: 1 ./run 1-dynamic-memory If you wish to run all tests, use the command: 1 ./run","title":"Testing Your Changes"},{"location":"set-up/#summary-of-commands","text":"Command Action ./gitconfig Initial git configuration ./update Update workspace with newly available problems ./run [folder name] Run unit tests to see how your programs perform","title":"Summary of commands"},{"location":"si-sessions/","text":"There are plenty of CPSC 131 Supplemental Instruction sections available. Below is the schedule. Date Time Room Leader Professor TuTh 2:30pm - 3:45pm CS 209 Daniel Walsh Anand Panangadan MoWe 10:00am - 11:15am CS 209 Gregory Vasquez Doina Bein MoWe 4:00pm - 5:15pm CS 209 Janeen Yamak Lakhanpal MoWe 5:30pm - 6:45pm CS 209 Oscar Olazabal Lakhanpal Note SI sessions may slightly vary in terms of content and presentation, as SI leaders are required to create an ajenda for their particular professor.","title":"SI Sessions"},{"location":"essentials/coding-exercise/","text":"Note If you have not configured you repository yet, please refer to this guide . You have to set it up in order to test your solutions. Retrieving The New Problem Set \u00b6 Please run 1 ./update To ensure you have the latest problem set. You should be able to see 1-dynamic-memory in your repository. The Code \u00b6 This week's exercise will focus on dynamic memory, as it is a fundametal aspect of data structures in C++. Specifically, you will be allocating, handling, and freeing memory in C++. This pattern of allocating, handling, and freeing memory is essential when creating data structures (as you will see later in the course). The 1-dynamic-memory codebase consists of a program that allows one to enroll students into a course. You will be filling in the empty functions in src/course.cpp in order complete this exercise. Warning In your repository, please only modify the highlighted regions in src/course.cpp indicated below include/course.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #ifndef COURSE_H #define COURSE_H #include \"student.h\" using namespace std ; class Course { private : size_t num_students , max_students ; int professor_cwid , class_num ; Student * students ; public : Course (); Course ( size_t max ); ~ Course (); Student get_student ( size_t index ) const ; void enroll_student ( const Student & student ); // Mutators void set_class_number ( int num ); void set_professor_cwid ( int id ); // Accessors int get_class_number () const ; size_t get_max_students () const ; size_t get_num_students () const ; int get_professor_cwid () const ; }; #endif include/student.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #ifndef STUDENT_H #define STUDENT_H #include \"string\" using namespace std ; class Student { private : int cwid ; string student_fname , student_lname ; public : // Contructors Student (); Student ( string fname , string lname , int id ); // Mutators void set_cwid ( int id ); void set_fname ( string fname ); void set_lname ( string lname ); // Accessors int get_cwid () const ; string get_fname () const ; string get_lname () const ; friend bool operator == ( const Student & lhs , const Student & rhs ); }; #endif src/course.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \"course.h\" #include \"student.h\" #include <stdexcept> using namespace std ; Course :: Course () { // Initialize member variables. // By default, course will hold a max of 25 students. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Course :: Course ( size_t max ) { // Very similar to default constructor, but parameter specifies max // number of students. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Course ::~ Course () { // Utilized to free allocated memory. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Student Course :: get_student ( size_t index ) const { // Fetch student at specified index. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return Student (); // ==================================================== } void Course :: enroll_student ( const Student & student ) { // Insert a new student // Utilize stdexcept to handle endge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } void Course :: set_class_number ( int num ) { class_num = num ; } void Course :: set_professor_cwid ( int id ) { professor_cwid = id ; } int Course :: get_class_number () const { return class_num ; } size_t Course :: get_max_students () const { return max_students ; } size_t Course :: get_num_students () const { return num_students ; } int Course :: get_professor_cwid () const { return professor_cwid ; } src/student.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"student.h\" Student :: Student () : cwid ( - 1 ) {} Student :: Student ( string fname , string lname , int id ) : cwid ( id ), student_fname ( fname ), student_lname ( lname ) {} void Student :: set_cwid ( int id ) { cwid = id ; } void Student :: set_fname ( string fname ) { student_fname = fname ; } void Student :: set_lname ( string lname ) { student_lname = lname ; } int Student :: get_cwid () const { return cwid ; } string Student :: get_fname () const { return student_fname ; } string Student :: get_lname () const { return student_lname ; } bool operator == ( const Student & lhs , const Student & rhs ) { return ( lhs . cwid == rhs . cwid && lhs . student_fname == rhs . student_fname && lhs . student_lname == rhs . student_lname ); } Testing \u00b6 After you have modified your code, test it! You can test it by running 1 ./run 1-dynamic-memory At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u276f ./run 1-dynamic-memory ================================================================================================================ COMPILING 1-dynamic-memory TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ================================================================================================================ RUNNING 1-dynamic-memory TESTS unit_test_1 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 3 tests from 1 test case. [----------] Global test environment set-up. [----------] 3 tests from Dynamic_Memory [ RUN ] Dynamic_Memory.Constructor [ OK ] Dynamic_Memory.Constructor (0 ms) [ RUN ] Dynamic_Memory.Enroll_Student [ OK ] Dynamic_Memory.Enroll_Student (0 ms) [ RUN ] Dynamic_Memory.Get_Student [ OK ] Dynamic_Memory.Get_Student (0 ms) [----------] 3 tests from Dynamic_Memory (0 ms total) [----------] Global test environment tear-down [==========] 3 tests from 1 test case ran. (0 ms total) [ PASSED ] 3 tests. ================================================================================================================ CLEANING 1-dynamic-memory UP ================================================================================================================","title":"Coding Exercise"},{"location":"essentials/coding-exercise/#retrieving-the-new-problem-set","text":"Please run 1 ./update To ensure you have the latest problem set. You should be able to see 1-dynamic-memory in your repository.","title":"Retrieving The New Problem Set"},{"location":"essentials/coding-exercise/#the-code","text":"This week's exercise will focus on dynamic memory, as it is a fundametal aspect of data structures in C++. Specifically, you will be allocating, handling, and freeing memory in C++. This pattern of allocating, handling, and freeing memory is essential when creating data structures (as you will see later in the course). The 1-dynamic-memory codebase consists of a program that allows one to enroll students into a course. You will be filling in the empty functions in src/course.cpp in order complete this exercise. Warning In your repository, please only modify the highlighted regions in src/course.cpp indicated below include/course.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #ifndef COURSE_H #define COURSE_H #include \"student.h\" using namespace std ; class Course { private : size_t num_students , max_students ; int professor_cwid , class_num ; Student * students ; public : Course (); Course ( size_t max ); ~ Course (); Student get_student ( size_t index ) const ; void enroll_student ( const Student & student ); // Mutators void set_class_number ( int num ); void set_professor_cwid ( int id ); // Accessors int get_class_number () const ; size_t get_max_students () const ; size_t get_num_students () const ; int get_professor_cwid () const ; }; #endif include/student.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #ifndef STUDENT_H #define STUDENT_H #include \"string\" using namespace std ; class Student { private : int cwid ; string student_fname , student_lname ; public : // Contructors Student (); Student ( string fname , string lname , int id ); // Mutators void set_cwid ( int id ); void set_fname ( string fname ); void set_lname ( string lname ); // Accessors int get_cwid () const ; string get_fname () const ; string get_lname () const ; friend bool operator == ( const Student & lhs , const Student & rhs ); }; #endif src/course.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \"course.h\" #include \"student.h\" #include <stdexcept> using namespace std ; Course :: Course () { // Initialize member variables. // By default, course will hold a max of 25 students. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Course :: Course ( size_t max ) { // Very similar to default constructor, but parameter specifies max // number of students. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Course ::~ Course () { // Utilized to free allocated memory. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } Student Course :: get_student ( size_t index ) const { // Fetch student at specified index. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return Student (); // ==================================================== } void Course :: enroll_student ( const Student & student ) { // Insert a new student // Utilize stdexcept to handle endge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } void Course :: set_class_number ( int num ) { class_num = num ; } void Course :: set_professor_cwid ( int id ) { professor_cwid = id ; } int Course :: get_class_number () const { return class_num ; } size_t Course :: get_max_students () const { return max_students ; } size_t Course :: get_num_students () const { return num_students ; } int Course :: get_professor_cwid () const { return professor_cwid ; } src/student.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"student.h\" Student :: Student () : cwid ( - 1 ) {} Student :: Student ( string fname , string lname , int id ) : cwid ( id ), student_fname ( fname ), student_lname ( lname ) {} void Student :: set_cwid ( int id ) { cwid = id ; } void Student :: set_fname ( string fname ) { student_fname = fname ; } void Student :: set_lname ( string lname ) { student_lname = lname ; } int Student :: get_cwid () const { return cwid ; } string Student :: get_fname () const { return student_fname ; } string Student :: get_lname () const { return student_lname ; } bool operator == ( const Student & lhs , const Student & rhs ) { return ( lhs . cwid == rhs . cwid && lhs . student_fname == rhs . student_fname && lhs . student_lname == rhs . student_lname ); }","title":"The Code"},{"location":"essentials/coding-exercise/#testing","text":"After you have modified your code, test it! You can test it by running 1 ./run 1-dynamic-memory At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u276f ./run 1-dynamic-memory ================================================================================================================ COMPILING 1-dynamic-memory TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ================================================================================================================ RUNNING 1-dynamic-memory TESTS unit_test_1 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 3 tests from 1 test case. [----------] Global test environment set-up. [----------] 3 tests from Dynamic_Memory [ RUN ] Dynamic_Memory.Constructor [ OK ] Dynamic_Memory.Constructor (0 ms) [ RUN ] Dynamic_Memory.Enroll_Student [ OK ] Dynamic_Memory.Enroll_Student (0 ms) [ RUN ] Dynamic_Memory.Get_Student [ OK ] Dynamic_Memory.Get_Student (0 ms) [----------] 3 tests from Dynamic_Memory (0 ms total) [----------] Global test environment tear-down [==========] 3 tests from 1 test case ran. (0 ms total) [ PASSED ] 3 tests. ================================================================================================================ CLEANING 1-dynamic-memory UP ================================================================================================================","title":"Testing"},{"location":"essentials/problems/","text":"C++ Types \u00b6 What is a C++ type? List as many C++ types as you can. Are pointers and references a C++ type? Pointers \u00b6 What does a pointer hold? Write a line of code that declares a pointer to a double. References \u00b6 What is a reference? Write a line of code that initializes a reference to a float variable named x . Referencing and dereferencing \u00b6 What does the reference operator do? What does the dereference operator do? Write a line of code that initializes a pointer to the address of an integer variable named y The following program performs pointer arithmetic. In general terms, what should the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <iostream> using namespace std ; int main () { int var = 5 ; int * ptr = & var ; cout << var << endl ; cout << & var << endl ; cout << ptr << endl ; cout << * ptr << endl ; cout << & ptr << endl ; } The following program performs reference arithmetic. In general terms, what should the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> using namespace std ; int main () { int var = 5 ; int & ref = var ; cout << var << endl ; cout << & var << endl ; cout << ref << endl ; cout << & ref << endl ; } Stack \u00b6 What is the stack used for? What are the limitations of the stack? Fill out the following table with respect to the program from question 4 in Referencing and Dereferencing and question 5 in Referencinng and Dereferencing Question 4 Variable name(s) Value Address Question 5 Variable name(s) Value Address Heap \u00b6 What is heap used for? What benefits does the heap have? What are the downsides to using the heap? What does it mean to dynamically allocate? What data type does the new keyword return? Why do pointers need to be used with dynamic memory? Write a line of code to deallocate the memory referenced by the pointer ptr . Fill out the stack and heap tables below with respect to following program. 1 2 3 4 5 6 7 8 9 10 11 #include <iostream> using namespace std ; int main () { int * iptr = nullptr ; iptr = new int ( 5 ); double * dptr ; double dvar = 5.8 ; dptr = & dvar ; } Stack Variable name(s) Value Address Heap Value Address Passing by Value vs Passing by Reference \u00b6 What does it mean to pass by reference? What does it mean to pass by value? What are the advantages of passing by reference? What are the advantages of passing by value? Consider the following functions: 1 2 3 4 5 6 7 8 9 10 11 void swap_a ( int a , int b ) { int temp = a ; a = b ; b = temp ; } void swap_b ( int & a , int & b ) { int temp = a ; a = b ; b = temp ; } What does the following program output? Does it pass by value or by reference? 1 2 3 4 5 6 7 8 9 #include <iostream> using namespace std ; int main () { int x ( 2 ), y ( 3 ); cout << x << \" \" << y << endl ; swap_a ( x , y ); cout << x << \" \" << y << endl ; } What does the following program output? Does it pass by value or by reference? 1 2 3 4 5 6 7 8 9 #include <iostream> using namespace std ; int main () { int x ( 2 ), y ( 3 ); cout << x << \" \" << y << endl ; swap_b ( x , y ); cout << x << \" \" << y << endl ; } Classes and Objects \u00b6 What are the differences between classes and objects? What are constructors and destructors? What is public and private? Design a class with the following details: class for cars private attributes: brand, lisencse plate public methods: set brand, set license plate, get brand, get license plate Create two objects from the class above. The first having the brand Ford and license plate number 1234567. The second having the brand name BMW and license plate 7654321.","title":"Problems"},{"location":"essentials/problems/#c-types","text":"What is a C++ type? List as many C++ types as you can. Are pointers and references a C++ type?","title":"C++ Types"},{"location":"essentials/problems/#pointers","text":"What does a pointer hold? Write a line of code that declares a pointer to a double.","title":"Pointers"},{"location":"essentials/problems/#references","text":"What is a reference? Write a line of code that initializes a reference to a float variable named x .","title":"References"},{"location":"essentials/problems/#referencing-and-dereferencing","text":"What does the reference operator do? What does the dereference operator do? Write a line of code that initializes a pointer to the address of an integer variable named y The following program performs pointer arithmetic. In general terms, what should the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <iostream> using namespace std ; int main () { int var = 5 ; int * ptr = & var ; cout << var << endl ; cout << & var << endl ; cout << ptr << endl ; cout << * ptr << endl ; cout << & ptr << endl ; } The following program performs reference arithmetic. In general terms, what should the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> using namespace std ; int main () { int var = 5 ; int & ref = var ; cout << var << endl ; cout << & var << endl ; cout << ref << endl ; cout << & ref << endl ; }","title":"Referencing and dereferencing"},{"location":"essentials/problems/#stack","text":"What is the stack used for? What are the limitations of the stack? Fill out the following table with respect to the program from question 4 in Referencing and Dereferencing and question 5 in Referencinng and Dereferencing Question 4 Variable name(s) Value Address Question 5 Variable name(s) Value Address","title":"Stack"},{"location":"essentials/problems/#heap","text":"What is heap used for? What benefits does the heap have? What are the downsides to using the heap? What does it mean to dynamically allocate? What data type does the new keyword return? Why do pointers need to be used with dynamic memory? Write a line of code to deallocate the memory referenced by the pointer ptr . Fill out the stack and heap tables below with respect to following program. 1 2 3 4 5 6 7 8 9 10 11 #include <iostream> using namespace std ; int main () { int * iptr = nullptr ; iptr = new int ( 5 ); double * dptr ; double dvar = 5.8 ; dptr = & dvar ; } Stack Variable name(s) Value Address Heap Value Address","title":"Heap"},{"location":"essentials/problems/#passing-by-value-vs-passing-by-reference","text":"What does it mean to pass by reference? What does it mean to pass by value? What are the advantages of passing by reference? What are the advantages of passing by value? Consider the following functions: 1 2 3 4 5 6 7 8 9 10 11 void swap_a ( int a , int b ) { int temp = a ; a = b ; b = temp ; } void swap_b ( int & a , int & b ) { int temp = a ; a = b ; b = temp ; } What does the following program output? Does it pass by value or by reference? 1 2 3 4 5 6 7 8 9 #include <iostream> using namespace std ; int main () { int x ( 2 ), y ( 3 ); cout << x << \" \" << y << endl ; swap_a ( x , y ); cout << x << \" \" << y << endl ; } What does the following program output? Does it pass by value or by reference? 1 2 3 4 5 6 7 8 9 #include <iostream> using namespace std ; int main () { int x ( 2 ), y ( 3 ); cout << x << \" \" << y << endl ; swap_b ( x , y ); cout << x << \" \" << y << endl ; }","title":"Passing by Value vs Passing by Reference"},{"location":"essentials/problems/#classes-and-objects","text":"What are the differences between classes and objects? What are constructors and destructors? What is public and private? Design a class with the following details: class for cars private attributes: brand, lisencse plate public methods: set brand, set license plate, get brand, get license plate Create two objects from the class above. The first having the brand Ford and license plate number 1234567. The second having the brand name BMW and license plate 7654321.","title":"Classes and Objects"},{"location":"graphs/coding-exercise/","text":"","title":"Coding exercise"},{"location":"graphs/problems/","text":"","title":"Problems"},{"location":"hash-tables/coding-exercise/","text":"","title":"Coding exercise"},{"location":"hash-tables/problems/","text":"","title":"Problems"},{"location":"linked-list/coding-exercise/","text":"Note If you have not configured you repository yet, please refer to this guide . You have to set it up in order to test your solutions. Retrieving The New Problem Set \u00b6 Please run 1 ./update To ensure you have the latest problem set. You should be able to see 3-singly-linked-list and 4-std-list in your repository. Singly Linked List \u00b6 The Code \u00b6 This week's exercise will focus on lists. Specifically, you will be implementing singly linked list functions within 3-singly-linked-list . The 3-singly-linked-list codebase consists of a partially complete singly linked list class. You will be filling in the empty functions in include/singly_linked_list.h in order complete this exercise. Warning In your repository, please only modify the highlighted regions in include/singly_linked_list.h indicated below include/singly_linked_list.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #ifndef SINGLY_LINKED_LIST_H #define SINGLY_LINKED_LIST_H #include <stdexcept> using namespace std ; template < typename T > struct Node { T data ; Node < T > * next ; Node () = delete ; // No default constructor Node ( const T & element ) : data ( element ), next ( nullptr ) {} }; template < typename T > class SinglyLinkedList { private : Node < T >* head ; Node < T >* tail ; public : SinglyLinkedList (); ~ SinglyLinkedList (); bool empty (); void prepend ( const T & ); void append ( const T & ); void pop_front (); T & front (); T & back (); void clear (); size_t size (); T & at ( size_t ); void swap_head_tail (); }; template < typename T > void SinglyLinkedList < T >:: clear () { // Delete every node in the linked list. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > size_t SinglyLinkedList < T >:: size () { // Return the number of nodes in the linked list. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return 0 ; // ==================================================== } template < typename T > T & SinglyLinkedList < T >:: at ( size_t i ) { // Return the data stored in the ith node // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return front (); // ==================================================== } template < typename T > void SinglyLinkedList < T >:: swap_head_tail () { // Swap the head and tail nodes in the linked list. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > SinglyLinkedList < T >:: SinglyLinkedList () : head ( nullptr ), tail ( nullptr ) {} template < typename T > SinglyLinkedList < T >::~ SinglyLinkedList () { clear (); } template < typename T > bool SinglyLinkedList < T >:: empty () { return head == nullptr ; } template < typename T > void SinglyLinkedList < T >:: append ( const T & newData ) { Node < T > * newNode = new Node < T > ( newData ); // create new node if ( head == nullptr ) { // List empty head = newNode ; tail = newNode ; } else { tail -> next = newNode ; tail = newNode ; } } template < typename T > void SinglyLinkedList < T >:: prepend ( const T & newData ) { Node < T > * newNode = new Node < T > ( newData ); // create new node if ( head == nullptr ) { // list empty head = newNode ; tail = newNode ; } else { newNode -> next = head ; head = newNode ; } } template < typename T > void SinglyLinkedList < T >:: pop_front () { if ( empty ()) throw length_error ( \"empty list\" ); Node < T > * temp = head ; head = head -> next ; delete temp ; if ( head == nullptr ) tail = nullptr ; } template < typename T > T & SinglyLinkedList < T >:: front () { if ( empty ()) throw std :: length_error ( \"empty list\" ); return head -> data ; } template < typename T > T & SinglyLinkedList < T >:: back () { if ( empty ()) throw std :: length_error ( \"empty list\" ); return tail -> data ; } #endif Testing \u00b6 After you have modified your code, test it! You can test it by running 1 ./run 3-singly-linked-list At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u276f ./run 3-singly-linked-list ============================================================================================== COMPILING 3-singly-linked-list TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ============================================================================================== RUNNING 3-singly-linked-list TESTS unit_test_3 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 4 tests from 1 test case. [----------] Global test environment set-up. [----------] 4 tests from Singly_Linked_List [ RUN ] Singly_Linked_List.Clear [ OK ] Singly_Linked_List.Clear (0 ms) [ RUN ] Singly_Linked_List.Size [ OK ] Singly_Linked_List.Size (0 ms) [ RUN ] Singly_Linked_List.At [ OK ] Singly_Linked_List.At (0 ms) [ RUN ] Singly_Linked_List.Swap_Head_And_Tail_Nodes [ OK ] Singly_Linked_List.Swap_Head_And_Tail_Nodes (0 ms) [----------] 4 tests from Singly_Linked_List (0 ms total) [----------] Global test environment tear-down [==========] 4 tests from 1 test case ran. (0 ms total) [ PASSED ] 4 tests. ============================================================================================== CLEANING 3-singly-linked-list UP ============================================================================================== STD List \u00b6 The Code \u00b6 In addition to the singly linked list implementation, we will also be leveraging the STL's implementation of a singly linked list. It is called a forward list. You will be performing operations on a forward list. The 4-std-list codebase consists of a incomplete functions that manipulate the forward list main_list . You will be filling in the empty functions in include/lists.h in order complete this exercise. Warning In your repository, please only modify the highlighted regions in include/lists.h indicated below include/lists.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #ifndef LISTS #define LISTS #include <list> #include <algorithm> using namespace std ; template < typename T > class ListQuestions { private : list < T > main_list ; public : ListQuestions ( list < T > ); list < T >& get_list (); void push_front_elements (); void pop_front_elements (); void delete_element (); typename list < T >:: iterator get_element ( const T & ); T sum (); void swap_elements (); void insert_elements ( const T & ); void sort (); void clear_elements (); }; // For the following tasks manipulate main_list. template < typename T > void ListQuestions < T >:: push_front_elements () { // Insert 3 elements at the front of the list // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: delete_element () { // Delete the third element from the front of the list // Example: // BEFORE: [ 1 2 4 6 1 4 . . . ] // ^ // AFTER: [ 1 2 6 1 4 . . . ] typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > typename list < T >:: iterator ListQuestions < T >:: get_element ( const T & elem ) { // Retreive an element from the list. Retrieve the element using an iterator. // Hint: utilize std::algorithm typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return it ; // ==================================================== } template < typename T > void ListQuestions < T >:: pop_front_elements () { // Remove 3 elements at the front of the list // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > T ListQuestions < T >:: sum () { // Find the sum of all of the elements of the list. Utilize iterators. typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return * it ; // ==================================================== } template < typename T > void ListQuestions < T >:: swap_elements () { // Swap the first and the last element in the list. Utilize iterators. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: insert_elements ( const T & elem ) { // Insert an element at the 3rd position in the list. // Example: // BEFORE: [ 1 2 4 6 1 4 . . . ] // ^ // AFTER: [ 1 2 n 4 6 1 4 . . . ] typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: sort () { // Sort the elements in the list in ascending order. // Hint: Use std::algorithm // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: clear_elements () { // Remove every element from the list. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > ListQuestions < T >:: ListQuestions ( list < T > copy_list ) { for ( T i : copy_list ) main_list . push_back ( i ); } template < typename T > list < T >& ListQuestions < T >:: get_list () { return main_list ; } #endif Testing \u00b6 After you have modified your code, test it! You can test it by running 1 ./run 4-std-list At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u276f ./run 4-std-list ============================================================================================ COMPILING 4-std-list TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ============================================================================================ RUNNING 4-std-list TESTS unit_test_4 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 9 tests from 1 test case. [----------] Global test environment set-up. [----------] 9 tests from [ RUN ] .Push_Front [ OK ] .Push_Front (0 ms) [ RUN ] .Delete_Element [ OK ] .Delete_Element (0 ms) [ RUN ] .Get_Element [ OK ] .Get_Element (0 ms) [ RUN ] .Pop_Front [ OK ] .Pop_Front (0 ms) [ RUN ] .Sum [ OK ] .Sum (0 ms) [ RUN ] .Swap [ OK ] .Swap (0 ms) [ RUN ] .Insert_Elements [ OK ] .Insert_Elements (0 ms) [ RUN ] .Sort [ OK ] .Sort (0 ms) [ RUN ] .Clear [ OK ] .Clear (0 ms) [----------] 9 tests from (0 ms total) [----------] Global test environment tear-down [==========] 9 tests from 1 test case ran. (1 ms total) [ PASSED ] 9 tests. ============================================================================================ CLEANING 4-std-list UP ============================================================================================","title":"Coding Exercise"},{"location":"linked-list/coding-exercise/#retrieving-the-new-problem-set","text":"Please run 1 ./update To ensure you have the latest problem set. You should be able to see 3-singly-linked-list and 4-std-list in your repository.","title":"Retrieving The New Problem Set"},{"location":"linked-list/coding-exercise/#singly-linked-list","text":"","title":"Singly Linked List"},{"location":"linked-list/coding-exercise/#the-code","text":"This week's exercise will focus on lists. Specifically, you will be implementing singly linked list functions within 3-singly-linked-list . The 3-singly-linked-list codebase consists of a partially complete singly linked list class. You will be filling in the empty functions in include/singly_linked_list.h in order complete this exercise. Warning In your repository, please only modify the highlighted regions in include/singly_linked_list.h indicated below include/singly_linked_list.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #ifndef SINGLY_LINKED_LIST_H #define SINGLY_LINKED_LIST_H #include <stdexcept> using namespace std ; template < typename T > struct Node { T data ; Node < T > * next ; Node () = delete ; // No default constructor Node ( const T & element ) : data ( element ), next ( nullptr ) {} }; template < typename T > class SinglyLinkedList { private : Node < T >* head ; Node < T >* tail ; public : SinglyLinkedList (); ~ SinglyLinkedList (); bool empty (); void prepend ( const T & ); void append ( const T & ); void pop_front (); T & front (); T & back (); void clear (); size_t size (); T & at ( size_t ); void swap_head_tail (); }; template < typename T > void SinglyLinkedList < T >:: clear () { // Delete every node in the linked list. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > size_t SinglyLinkedList < T >:: size () { // Return the number of nodes in the linked list. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return 0 ; // ==================================================== } template < typename T > T & SinglyLinkedList < T >:: at ( size_t i ) { // Return the data stored in the ith node // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return front (); // ==================================================== } template < typename T > void SinglyLinkedList < T >:: swap_head_tail () { // Swap the head and tail nodes in the linked list. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > SinglyLinkedList < T >:: SinglyLinkedList () : head ( nullptr ), tail ( nullptr ) {} template < typename T > SinglyLinkedList < T >::~ SinglyLinkedList () { clear (); } template < typename T > bool SinglyLinkedList < T >:: empty () { return head == nullptr ; } template < typename T > void SinglyLinkedList < T >:: append ( const T & newData ) { Node < T > * newNode = new Node < T > ( newData ); // create new node if ( head == nullptr ) { // List empty head = newNode ; tail = newNode ; } else { tail -> next = newNode ; tail = newNode ; } } template < typename T > void SinglyLinkedList < T >:: prepend ( const T & newData ) { Node < T > * newNode = new Node < T > ( newData ); // create new node if ( head == nullptr ) { // list empty head = newNode ; tail = newNode ; } else { newNode -> next = head ; head = newNode ; } } template < typename T > void SinglyLinkedList < T >:: pop_front () { if ( empty ()) throw length_error ( \"empty list\" ); Node < T > * temp = head ; head = head -> next ; delete temp ; if ( head == nullptr ) tail = nullptr ; } template < typename T > T & SinglyLinkedList < T >:: front () { if ( empty ()) throw std :: length_error ( \"empty list\" ); return head -> data ; } template < typename T > T & SinglyLinkedList < T >:: back () { if ( empty ()) throw std :: length_error ( \"empty list\" ); return tail -> data ; } #endif","title":"The Code"},{"location":"linked-list/coding-exercise/#testing","text":"After you have modified your code, test it! You can test it by running 1 ./run 3-singly-linked-list At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u276f ./run 3-singly-linked-list ============================================================================================== COMPILING 3-singly-linked-list TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ============================================================================================== RUNNING 3-singly-linked-list TESTS unit_test_3 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 4 tests from 1 test case. [----------] Global test environment set-up. [----------] 4 tests from Singly_Linked_List [ RUN ] Singly_Linked_List.Clear [ OK ] Singly_Linked_List.Clear (0 ms) [ RUN ] Singly_Linked_List.Size [ OK ] Singly_Linked_List.Size (0 ms) [ RUN ] Singly_Linked_List.At [ OK ] Singly_Linked_List.At (0 ms) [ RUN ] Singly_Linked_List.Swap_Head_And_Tail_Nodes [ OK ] Singly_Linked_List.Swap_Head_And_Tail_Nodes (0 ms) [----------] 4 tests from Singly_Linked_List (0 ms total) [----------] Global test environment tear-down [==========] 4 tests from 1 test case ran. (0 ms total) [ PASSED ] 4 tests. ============================================================================================== CLEANING 3-singly-linked-list UP ==============================================================================================","title":"Testing"},{"location":"linked-list/coding-exercise/#std-list","text":"","title":"STD List"},{"location":"linked-list/coding-exercise/#the-code_1","text":"In addition to the singly linked list implementation, we will also be leveraging the STL's implementation of a singly linked list. It is called a forward list. You will be performing operations on a forward list. The 4-std-list codebase consists of a incomplete functions that manipulate the forward list main_list . You will be filling in the empty functions in include/lists.h in order complete this exercise. Warning In your repository, please only modify the highlighted regions in include/lists.h indicated below include/lists.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #ifndef LISTS #define LISTS #include <list> #include <algorithm> using namespace std ; template < typename T > class ListQuestions { private : list < T > main_list ; public : ListQuestions ( list < T > ); list < T >& get_list (); void push_front_elements (); void pop_front_elements (); void delete_element (); typename list < T >:: iterator get_element ( const T & ); T sum (); void swap_elements (); void insert_elements ( const T & ); void sort (); void clear_elements (); }; // For the following tasks manipulate main_list. template < typename T > void ListQuestions < T >:: push_front_elements () { // Insert 3 elements at the front of the list // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: delete_element () { // Delete the third element from the front of the list // Example: // BEFORE: [ 1 2 4 6 1 4 . . . ] // ^ // AFTER: [ 1 2 6 1 4 . . . ] typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > typename list < T >:: iterator ListQuestions < T >:: get_element ( const T & elem ) { // Retreive an element from the list. Retrieve the element using an iterator. // Hint: utilize std::algorithm typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return it ; // ==================================================== } template < typename T > void ListQuestions < T >:: pop_front_elements () { // Remove 3 elements at the front of the list // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > T ListQuestions < T >:: sum () { // Find the sum of all of the elements of the list. Utilize iterators. typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return * it ; // ==================================================== } template < typename T > void ListQuestions < T >:: swap_elements () { // Swap the first and the last element in the list. Utilize iterators. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: insert_elements ( const T & elem ) { // Insert an element at the 3rd position in the list. // Example: // BEFORE: [ 1 2 4 6 1 4 . . . ] // ^ // AFTER: [ 1 2 n 4 6 1 4 . . . ] typename list < T >:: iterator it = main_list . begin (); // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: sort () { // Sort the elements in the list in ascending order. // Hint: Use std::algorithm // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > void ListQuestions < T >:: clear_elements () { // Remove every element from the list. // ========= ONLY MODIFY BETWEEN THE LINES =========== return ; // ==================================================== } template < typename T > ListQuestions < T >:: ListQuestions ( list < T > copy_list ) { for ( T i : copy_list ) main_list . push_back ( i ); } template < typename T > list < T >& ListQuestions < T >:: get_list () { return main_list ; } #endif","title":"The Code"},{"location":"linked-list/coding-exercise/#testing_1","text":"After you have modified your code, test it! You can test it by running 1 ./run 4-std-list At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u276f ./run 4-std-list ============================================================================================ COMPILING 4-std-list TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ============================================================================================ RUNNING 4-std-list TESTS unit_test_4 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 9 tests from 1 test case. [----------] Global test environment set-up. [----------] 9 tests from [ RUN ] .Push_Front [ OK ] .Push_Front (0 ms) [ RUN ] .Delete_Element [ OK ] .Delete_Element (0 ms) [ RUN ] .Get_Element [ OK ] .Get_Element (0 ms) [ RUN ] .Pop_Front [ OK ] .Pop_Front (0 ms) [ RUN ] .Sum [ OK ] .Sum (0 ms) [ RUN ] .Swap [ OK ] .Swap (0 ms) [ RUN ] .Insert_Elements [ OK ] .Insert_Elements (0 ms) [ RUN ] .Sort [ OK ] .Sort (0 ms) [ RUN ] .Clear [ OK ] .Clear (0 ms) [----------] 9 tests from (0 ms total) [----------] Global test environment tear-down [==========] 9 tests from 1 test case ran. (1 ms total) [ PASSED ] 9 tests. ============================================================================================ CLEANING 4-std-list UP ============================================================================================","title":"Testing"},{"location":"linked-list/problems/","text":"Why Linked Lists? \u00b6 What are the performance limitations of vectors? What are the space limitations of vectors? What capabilities do linked lists provide that vectors do not? What capabilities do vectors provice that linked list do not? Give an example in which you would utilize a linked list over a vector? What about a vector over a linked list? Performance of Linked Lists \u00b6 What would be the Big O of inserting a single node into a linked list? What is the Big O of remove a single node frome a linked list? What is the space complexity of storing nodes in a linked list? What is the time complexity of a linear search of a linked list? Can you perform a traditional binary serach of a linked list? If so, what is the Big O of the search? What is the Big O of printing all elements in a linked list? Implementation of Linked Lists \u00b6 A linked list is built using nodes. The following is the implementation of a node for a Singly Linked List in C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <iostream> using namespace std ; template < typename T > class Node { T data ; Node < T > * next ; Node () : next ( nullptr ) {} }; int main () { Node < int > * head = nullptr ; } 1. Sketch the linked list for the following code snippet. Assume the Node class has been defined. 1 2 3 4 5 6 7 8 int main () { Node < int > * head = new Node < T > (); head -> data = 0 ; head -> next = new Node < T > (); head -> next -> data = 1 ; head -> next -> next = new Node < T > (); head -> next -> next -> data = 2 } 2. Does the following code have a memory leak? 1 2 3 4 5 6 7 8 9 10 int main () { Node < int > * head = new Node < T > (); head -> data = 0 ; Node < int > * newNode = new Node < T > (); newNode -> data = 1 head -> next = newNode ; newNode -> next = new Node < T > (); newNode -> next -> data = 2 ; newNode = newNode -> next ; } Forward List - Standard Template Library \u00b6 CPP Forward List reference: http://www.cplusplus.com/reference/forward_list/forward_list/ What header needs to be included to utilize forward lists? What functions are utilized to add and remove items from the forward list? Declare a forward list and push the integers 1, 2, 3. Print the elements stored in the list. In what order are the elements printed? Why? What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <forward_list> using namespace std ; int main () { forward_list < int > list ; for ( int i = 0 ; i < 10 ; i ++ ) list . push_front ( i ); for ( int i = 0 ; i < 5 ; i ++ ) list . pop_front (); cout << endl ; for ( int i : list ) cout << i << \" \" ; } What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> #include <forward_list> using namespace std ; int main () { forward_list < int > list ; for ( int i = 10 ; i > 0 ; i -- ) list . push_front ( i ); list . pop_front (); cout << list . front (); }","title":"Problems"},{"location":"linked-list/problems/#why-linked-lists","text":"What are the performance limitations of vectors? What are the space limitations of vectors? What capabilities do linked lists provide that vectors do not? What capabilities do vectors provice that linked list do not? Give an example in which you would utilize a linked list over a vector? What about a vector over a linked list?","title":"Why Linked Lists?"},{"location":"linked-list/problems/#performance-of-linked-lists","text":"What would be the Big O of inserting a single node into a linked list? What is the Big O of remove a single node frome a linked list? What is the space complexity of storing nodes in a linked list? What is the time complexity of a linear search of a linked list? Can you perform a traditional binary serach of a linked list? If so, what is the Big O of the search? What is the Big O of printing all elements in a linked list?","title":"Performance of Linked Lists"},{"location":"linked-list/problems/#implementation-of-linked-lists","text":"A linked list is built using nodes. The following is the implementation of a node for a Singly Linked List in C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <iostream> using namespace std ; template < typename T > class Node { T data ; Node < T > * next ; Node () : next ( nullptr ) {} }; int main () { Node < int > * head = nullptr ; } 1. Sketch the linked list for the following code snippet. Assume the Node class has been defined. 1 2 3 4 5 6 7 8 int main () { Node < int > * head = new Node < T > (); head -> data = 0 ; head -> next = new Node < T > (); head -> next -> data = 1 ; head -> next -> next = new Node < T > (); head -> next -> next -> data = 2 } 2. Does the following code have a memory leak? 1 2 3 4 5 6 7 8 9 10 int main () { Node < int > * head = new Node < T > (); head -> data = 0 ; Node < int > * newNode = new Node < T > (); newNode -> data = 1 head -> next = newNode ; newNode -> next = new Node < T > (); newNode -> next -> data = 2 ; newNode = newNode -> next ; }","title":"Implementation of Linked Lists"},{"location":"linked-list/problems/#forward-list-standard-template-library","text":"CPP Forward List reference: http://www.cplusplus.com/reference/forward_list/forward_list/ What header needs to be included to utilize forward lists? What functions are utilized to add and remove items from the forward list? Declare a forward list and push the integers 1, 2, 3. Print the elements stored in the list. In what order are the elements printed? Why? What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <forward_list> using namespace std ; int main () { forward_list < int > list ; for ( int i = 0 ; i < 10 ; i ++ ) list . push_front ( i ); for ( int i = 0 ; i < 5 ; i ++ ) list . pop_front (); cout << endl ; for ( int i : list ) cout << i << \" \" ; } What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 #include <iostream> #include <forward_list> using namespace std ; int main () { forward_list < int > list ; for ( int i = 10 ; i > 0 ; i -- ) list . push_front ( i ); list . pop_front (); cout << list . front (); }","title":"Forward List - Standard Template Library"},{"location":"runtime/problems/","text":"Concepts \u00b6 What does time complexity mean? What is upper bound? Lower bound? What is the difference between O(1) and O(N)? Why is it important to consider worst-case when developing an algorithm? Big O Exercises \u00b6 Give the Big O of the following snippets of code Example 1 1 2 3 4 5 6 7 8 int min = INT_MIN ; int max = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ]; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ]; } Example 2 1 2 3 4 5 6 int min = INT_MIN ; int max = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ]; if ( arr [ i ] > max ) max = arr [ i ]; } Example 3 1 2 3 4 5 6 7 8 9 void foo ( int arr [], int size ) { int sum = 0 ; int product = 1 ; for ( int i = 0 ; i < size , i ++ ) sum += arr [ i ]; for ( int i = 0 ; i < size ; i ++ ) product *= arr [ i ]; cout << sum << \", \" << product ; } Example 4 1 2 3 4 5 void printPairs ( int arr [], int size ) { for ( int i = 0 ; i < size , i ++ ) for ( int j = 0 ; j < size ; j ++ ) cout << arr [ i ] << \" \" << arr [ j ]; } Example 5 1 2 3 4 5 void printUnorderedPairs ( int arr [], int size ) { for ( int i = 0 ; i < size , i ++ ) for ( int j = i + 1 ; j < size ; j ++ ) cout << arr [ i ] << \" \" << arr [ j ]; }","title":"Problems"},{"location":"runtime/problems/#concepts","text":"What does time complexity mean? What is upper bound? Lower bound? What is the difference between O(1) and O(N)? Why is it important to consider worst-case when developing an algorithm?","title":"Concepts"},{"location":"runtime/problems/#big-o-exercises","text":"Give the Big O of the following snippets of code","title":"Big O Exercises"},{"location":"stacks-queues/coding-exercise/","text":"","title":"Coding Exercise"},{"location":"stacks-queues/problems/","text":"Stacks \u00b6 In what order are operations performed with a stack? What are the basic operations for a stack? What is a real life example of a stack? What are the time complexities of the operations? In what ways can you implement a stack? Draw the end state of the following stack: 1 2 3 4 5 6 7 8 push(3) push(3) pop() push(7) pop() push(9) push(2) pop() Queues \u00b6 In what order are operations performed with a queue? What are the basic operations for a queue? What are the time complexities of the operations?","title":"Problems"},{"location":"stacks-queues/problems/#stacks","text":"In what order are operations performed with a stack? What are the basic operations for a stack? What is a real life example of a stack? What are the time complexities of the operations? In what ways can you implement a stack? Draw the end state of the following stack: 1 2 3 4 5 6 7 8 push(3) push(3) pop() push(7) pop() push(9) push(2) pop()","title":"Stacks"},{"location":"stacks-queues/problems/#queues","text":"In what order are operations performed with a queue? What are the basic operations for a queue? What are the time complexities of the operations?","title":"Queues"},{"location":"trees/coding-exercise/","text":"","title":"Coding exercise"},{"location":"trees/problems/","text":"","title":"Problems"},{"location":"vectors/coding-exercise/","text":"Note If you have not configured you repository yet, please refer to this guide . You have to set it up in order to test your solutions. Retrieving The New Problem Set \u00b6 Please run 1 ./update To ensure you have the latest problem set. You should be able to see 2-fixed-vector in your repository. The Code \u00b6 This week's exercise will focus on vectors. Specifically, you will be implementing your very own fixed vector class. Fixed vectors are similar to standard vectors, except for the fact that fixed vectors do not dynamically grow/shrink. The 2-fixed-vector codebase consists of a partially complete fixed vector class. You will be filling in the empty functions in include/fixed_vector.h in order complete this exercise. Warning In your repository, please only modify the highlighted regions in include/fixed_vector.h indicated below include/fixed_vector.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #ifndef FIXED_VECTOR_H #define FIXED_VECTOR_H #include <stdexcept> using namespace std ; template < typename T > class FixedVector { private : size_t capacity , size ; T * arr ; public : FixedVector (); FixedVector ( size_t cap ); FixedVector ( const FixedVector & rhs ); ~ FixedVector (); void push_back ( const T & elem ); void pop_back (); T at ( const size_t index ) const ; size_t get_capacity (); size_t get_size (); T & operator [] ( size_t index ); }; template < typename T > FixedVector < T >:: FixedVector ( const FixedVector & rhs ) { // Implement the copy constructor. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } template < typename T > void FixedVector < T >:: push_back ( const T & elem ) { // Insert an element at the next available index of the array. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } template < typename T > void FixedVector < T >:: pop_back () { // Remove element from the back of the vector. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } template < typename T > T FixedVector < T >:: at ( const size_t index ) const { // Retrieve the element at the specified index. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return arr [ 0 ]; // ==================================================== } template < typename T > T & FixedVector < T >:: operator []( const size_t index ) { // Retrieve the element at the specified index. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return arr [ 0 ]; // ==================================================== } template < typename T > FixedVector < T >:: FixedVector () { capacity = 100 ; size = 0 ; arr = new T [ capacity ]; } template < typename T > FixedVector < T >:: FixedVector ( size_t cap ) { capacity = cap ; size = 0 ; arr = new T [ capacity ]; } template < typename T > FixedVector < T >::~ FixedVector () { delete [] arr ; } template < typename T > size_t FixedVector < T >:: get_capacity () { return capacity ; } template < typename T > size_t FixedVector < T >:: get_size () { return size ; } #endif Testing \u00b6 After you have modified your code, test it! You can test it by running 1 ./run 2-fixed-vector At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u276f ./run 2-fixed-vector ================================================================================================================ COMPILING 2-fixed-vector TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ================================================================================================================ RUNNING 2-fixed-vector TESTS unit_test_2 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 5 tests from 1 test case. [----------] Global test environment set-up. [----------] 5 tests from Fixed_Vector [ RUN ] Fixed_Vector.Copy_Constructor [ OK ] Fixed_Vector.Copy_Constructor (0 ms) [ RUN ] Fixed_Vector.Push_Back [ OK ] Fixed_Vector.Push_Back (0 ms) [ RUN ] Fixed_Vector.Pop_Back [ OK ] Fixed_Vector.Pop_Back (0 ms) [ RUN ] Fixed_Vector.At [ OK ] Fixed_Vector.At (0 ms) [ RUN ] Fixed_Vector.Operator_Overloading [ OK ] Fixed_Vector.Operator_Overloading (0 ms) [----------] 5 tests from Fixed_Vector (0 ms total) [----------] Global test environment tear-down [==========] 5 tests from 1 test case ran. (0 ms total) [ PASSED ] 5 tests. ================================================================================================================ CLEANING 2-fixed-vector UP ================================================================================================================","title":"Coding Exercise"},{"location":"vectors/coding-exercise/#retrieving-the-new-problem-set","text":"Please run 1 ./update To ensure you have the latest problem set. You should be able to see 2-fixed-vector in your repository.","title":"Retrieving The New Problem Set"},{"location":"vectors/coding-exercise/#the-code","text":"This week's exercise will focus on vectors. Specifically, you will be implementing your very own fixed vector class. Fixed vectors are similar to standard vectors, except for the fact that fixed vectors do not dynamically grow/shrink. The 2-fixed-vector codebase consists of a partially complete fixed vector class. You will be filling in the empty functions in include/fixed_vector.h in order complete this exercise. Warning In your repository, please only modify the highlighted regions in include/fixed_vector.h indicated below include/fixed_vector.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #ifndef FIXED_VECTOR_H #define FIXED_VECTOR_H #include <stdexcept> using namespace std ; template < typename T > class FixedVector { private : size_t capacity , size ; T * arr ; public : FixedVector (); FixedVector ( size_t cap ); FixedVector ( const FixedVector & rhs ); ~ FixedVector (); void push_back ( const T & elem ); void pop_back (); T at ( const size_t index ) const ; size_t get_capacity (); size_t get_size (); T & operator [] ( size_t index ); }; template < typename T > FixedVector < T >:: FixedVector ( const FixedVector & rhs ) { // Implement the copy constructor. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } template < typename T > void FixedVector < T >:: push_back ( const T & elem ) { // Insert an element at the next available index of the array. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } template < typename T > void FixedVector < T >:: pop_back () { // Remove element from the back of the vector. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== // ==================================================== } template < typename T > T FixedVector < T >:: at ( const size_t index ) const { // Retrieve the element at the specified index. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return arr [ 0 ]; // ==================================================== } template < typename T > T & FixedVector < T >:: operator []( const size_t index ) { // Retrieve the element at the specified index. // Utilize stdexcept to handle edge cases. // ========= ONLY MODIFY BETWEEN THE LINES =========== return arr [ 0 ]; // ==================================================== } template < typename T > FixedVector < T >:: FixedVector () { capacity = 100 ; size = 0 ; arr = new T [ capacity ]; } template < typename T > FixedVector < T >:: FixedVector ( size_t cap ) { capacity = cap ; size = 0 ; arr = new T [ capacity ]; } template < typename T > FixedVector < T >::~ FixedVector () { delete [] arr ; } template < typename T > size_t FixedVector < T >:: get_capacity () { return capacity ; } template < typename T > size_t FixedVector < T >:: get_size () { return size ; } #endif","title":"The Code"},{"location":"vectors/coding-exercise/#testing","text":"After you have modified your code, test it! You can test it by running 1 ./run 2-fixed-vector At the root of your repository. If you've successfully implemented all of the functions, your output should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u276f ./run 2-fixed-vector ================================================================================================================ COMPILING 2-fixed-vector TESTS ar: creating archive libgtest.a a - gtest-all.o ar: creating archive libgtest_main.a a - gtest-all.o a - gtest_main.o ================================================================================================================ RUNNING 2-fixed-vector TESTS unit_test_2 Running main() from /Users/oscar/Documents/projects/si-spring-2019/googletest/src/gtest_main.cc [==========] Running 5 tests from 1 test case. [----------] Global test environment set-up. [----------] 5 tests from Fixed_Vector [ RUN ] Fixed_Vector.Copy_Constructor [ OK ] Fixed_Vector.Copy_Constructor (0 ms) [ RUN ] Fixed_Vector.Push_Back [ OK ] Fixed_Vector.Push_Back (0 ms) [ RUN ] Fixed_Vector.Pop_Back [ OK ] Fixed_Vector.Pop_Back (0 ms) [ RUN ] Fixed_Vector.At [ OK ] Fixed_Vector.At (0 ms) [ RUN ] Fixed_Vector.Operator_Overloading [ OK ] Fixed_Vector.Operator_Overloading (0 ms) [----------] 5 tests from Fixed_Vector (0 ms total) [----------] Global test environment tear-down [==========] 5 tests from 1 test case ran. (0 ms total) [ PASSED ] 5 tests. ================================================================================================================ CLEANING 2-fixed-vector UP ================================================================================================================","title":"Testing"},{"location":"vectors/problems/","text":"Arrays \u00b6 What are data structures? What are the limitations of arrays? Vector Concepts \u00b6 What happens to a vector when it reaches capacitry, as opposed to an array? What fundamental attributes are required in order to create a vector class? What does the constructor of a vector class do? What about the destructor? What is the difference between a vector's capacity and a vector's size? What are the big O's of a vector's push back, insert, and erase functions? Vectors - Standard Template Library \u00b6 CPP Vector reference: http://www.cplusplus.com/reference/vector/vector/ What is the standard template library? What header needs to be included to utilize vectors? What functions are utilized to add and remove items from the end of the vector? What functions are utilized to check the vectors size and capacity? Write a two vector declarations. One that stores integers and another that stores objects from a class named Students. What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vect ; for ( int i = 0 ; i < 5 ; i ++ ) vect . push_back ( i ); for ( int i = 0 ; i < 5 ; i ++ ) cout << vect [ i ] << \" \" ; cout << endl ; for ( int i : vect ) cout << i << \" \" ; } What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vect ( 5 ); for ( int i : vect ) cout << i << \" \" ; vect . resize ( 3 ); vect [ 1 ] = 5 ; cout << endl ; for ( int i : vect ) cout << i << \" \" ; } What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vect ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; vect . push_back ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; vect . push_back ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; vect . push_back ( 1 ); vect . push_back ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; }","title":"Problems"},{"location":"vectors/problems/#arrays","text":"What are data structures? What are the limitations of arrays?","title":"Arrays"},{"location":"vectors/problems/#vector-concepts","text":"What happens to a vector when it reaches capacitry, as opposed to an array? What fundamental attributes are required in order to create a vector class? What does the constructor of a vector class do? What about the destructor? What is the difference between a vector's capacity and a vector's size? What are the big O's of a vector's push back, insert, and erase functions?","title":"Vector Concepts"},{"location":"vectors/problems/#vectors-standard-template-library","text":"CPP Vector reference: http://www.cplusplus.com/reference/vector/vector/ What is the standard template library? What header needs to be included to utilize vectors? What functions are utilized to add and remove items from the end of the vector? What functions are utilized to check the vectors size and capacity? Write a two vector declarations. One that stores integers and another that stores objects from a class named Students. What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vect ; for ( int i = 0 ; i < 5 ; i ++ ) vect . push_back ( i ); for ( int i = 0 ; i < 5 ; i ++ ) cout << vect [ i ] << \" \" ; cout << endl ; for ( int i : vect ) cout << i << \" \" ; } What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vect ( 5 ); for ( int i : vect ) cout << i << \" \" ; vect . resize ( 3 ); vect [ 1 ] = 5 ; cout << endl ; for ( int i : vect ) cout << i << \" \" ; } What does the following program output? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vect ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; vect . push_back ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; vect . push_back ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; vect . push_back ( 1 ); vect . push_back ( 1 ); cout << \"size: \" << vect . size () << endl ; cout << \"capacity: \" << vect . capacity () << endl << endl ; }","title":"Vectors - Standard Template Library"}]}